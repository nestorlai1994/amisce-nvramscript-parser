package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/nestorlai1994/amisce-nvramscript-parser/internal/item"
)

type Diff struct {
	ValueDiff  []item.Item `json:"value_diff"`
	FirstOnly  []item.Item `json:"first_only"`
	SecondOnly []item.Item `json:"second_only"`
}

func main() {
	fmt.Println("Welcome to the NVRAM Script Diff!")
	fmt.Println("This program compares two NVRAM script files which are generated by nvramscript-parser.go and outputs the differences.")

	ffile := os.Args[1]
	sfile := os.Args[2]

	offile := openFile(ffile)
	osfile := openFile(sfile)

	fitems := unmarshal(offile)
	sitems := unmarshal(osfile)

	fmap := generateMap(fitems)
	smap := generateMap(sitems)

	diff := Diff{
		ValueDiff:  make([]item.Item, 0),
		FirstOnly:  make([]item.Item, 0),
		SecondOnly: make([]item.Item, 0),
	}

	for k, v := range fmap {
		if _, ok := smap[k]; !ok {
			fmt.Println("Item not found in second file: ", string(k))
			if !bytes.Contains(v.Question, []byte("Boot Option")) {
				v.FileName = []byte(ffile)
				diff.FirstOnly = append(diff.FirstOnly, v)
				delete(fmap, k)
			}
		} else if v.IsValueEqual(smap[k].Value) {
			delete(fmap, k)
			delete(smap, k)
		}
	}

	deleteBootOption(fmap)
	deleteBootOption(smap)

	for k, v := range fmap {
		v.FileName = []byte(ffile)
		diff.ValueDiff = append(diff.ValueDiff, v)
		sv := smap[k]
		sv.FileName = []byte(sfile)
		diff.ValueDiff = append(diff.ValueDiff, sv)
		delete(smap, k)
	}

	for _, v := range smap {
		v.FileName = []byte(sfile)
		diff.SecondOnly = append(diff.SecondOnly, v)
	}

	b, _ := json.MarshalIndent(diff, "", "  ")
	exportToJson(b, "/tmp/diff.json")
}

func openFile(file string) []byte {
	f, err := os.Open(file)
	if err != nil {
		fmt.Println("Error opening file: ", err)
	}
	defer f.Close()
	b, _ := io.ReadAll(f)
	return b
}

func unmarshal(file []byte) []item.Item {
	var items []item.Item
	json.Unmarshal(file, &items)
	return items
}

func generateMap(items []item.Item) map[string]item.Item {
	m := make(map[string]item.Item)
	for _, item := range items {
		m[string(item.Question)] = item
	}
	return m
}

func deleteBootOption(m map[string]item.Item) {
	for k := range m {
		if strings.Contains(k, "Boot Option") {
			delete(m, k)
		}
	}
}

func exportToJson(b []byte, path string) {
	f, err := os.Create(path)
	if err != nil {
		fmt.Println("Error creating file: ", err)
	}
	defer f.Close()
	f.Write(b)
}
